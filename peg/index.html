<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Peggy</title>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type="text/javascript" src="peg-0.8.0.js"></script>
<script type="text/javascript" src="jsonpath.js"></script>

<script type='text/javascript'>

var templates = {};
var formats = {
	currency : function(v)	{
		return v;
		},
	truncate : function(v)	{
		return v;
		},
	prepend : function(v)	{
		return v;
		},
	append : function(v)	{}
	}
var sampleProdData = {
		"product" : {
			"name" : "This is a product name.",
			"base_price" : "5.23",
			"created" : 1391714080,
			"prod_image1" : "181657/24255646",
			"prod_msrp" : "",
			"prod_desc" : "Bacon ipsum dolor sit amet doner chicken ham hock swine meatball leberkas pancetta. Ham pastrami frankfurter brisket tail spare ribs pork chop rump beef ribs corned beef porchetta short ribs boudin capicola strip steak. Biltong jowl pork belly meatloaf jerky turkey. Bresaola strip steak andouille, porchetta turducken tongue ribeye ham pork chop. Kevin filet mignon strip steak brisket. Kevin turkey pastrami pork ham hock. Bacon ribeye beef ribs ham, shoulder swine flank strip steak pork chop prosciutto t-bone ground round."
			}
		}
var pegParser; //declared globally. this will be part of _app... most likely.

//here just for testing instances.
var bob; 
var frank;




/*

have a function for convert args to hash.
This will allow us to easily check to see if --empty AND --img (or any two verbs in apply) are set and to process them all.

NOTES -> a single CMD could have several formats in the args.  The args are gonna be condensed down into one hash per rule.
formats are processed in order.
apply is processed in a specific order. empty, then remove, then 'magic' (images, etc), then append/prepend/inner/etc.

*/



//creates an instance of the template, in memory.
//interpolates all data-tlc on that template.
//returns the template.
var peggy = function(templateID, data)	{

	this.templateID = templateID;
	this.data = data;

//used w/ peg parser for tlc errors.
	this.buildErrorMessage = function(e) {
		return e.line !== undefined && e.column !== undefined ? "Line " + e.line + ", column " + e.column + ": " + e.message : e.message;
		}
//This is where the magic happens. Run this and the translated template will be returned.
	this.translateTemplate = function()	{
		var _self = this; //'this' context is lost within each loop.
		var $t = window.templates[templateID].clone();
//		console.log(" -> running peggyInstance.translateTemplate. data-tlc.length: "+$("[data-tlc]",$t).length);
		$("[data-tlc]",$t).addBack("[data-tlc]").each(function(index,value){
			var $tag = $(this), tlc = $tag.data('tlc');
			console.log("----------------> start new $tag <-----------------");
			var commands = false;
			try{
				commands = window.pegParser.parse(tlc);
				}
			catch(e)	{
				console.log(self.buildErrorMessage(e));
//				console.log("attempt to run parse on "+tlc+" failed w/ the following error(s):");
				}

			if(commands && !$.isEmptyObject(commands))	{
				_self.executeCommands($tag,commands);
				}
			else	{
				console.warn("couldn't parse a tlc");
				//could not parse tlc. error already reported.
				}
			console.log("----------------> end $tag <-----------------");
			});
		return $t;
		} //translateTemplate

//used in 'apply' and possibly elsewhere. changes the args arrays into a single object for easy lookup.
	this.args2obj = function(args)	{
		var r = {};
		for(var i = 0, L = args.length; i < L; i += 1)	{
			r[args[i].key] = (args[i].value && args[i].value.value) ? args[i].value.value : true; //some keys, like append or media, have no value.
			}
		return r;
		}

//The vars object should match up to what the attributes are on the image tag. It means the object used to create this instance can also be passed directly into a .attr()
	this.makeImageURL	= function(vars)	{
		if(vars['data-bgcolor'].charAt(0) == '#')	{vars['data-bgcolor'] = vars['data-bgcolor'].substr(1)}
		var url = (vars.width ? "-W"+vars.width : "")+(vars.height ? "-H"+vars.height : "")+(vars['data-bgcolor'] ? "-B"+vars['data-bgcolor'] : "")+(vars['data-minimal'] ? "-M" : "")+"/"+vars['data-filename']
		//don't want the first character to be a -. all params are optional, stripping first char is the most efficient way to build the path.
		return "http://www.sporks.zoovy.com/media/img/-/"+url.substr(1); //### TODO -> obviously, we don't want sporks info in URL.
		}




/* //////////////////////////////     FORMATS	 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */



//passing the command into this will verify that the format exists (whether it be core or not)
//may be able to merge this with the handler_apply. We'll see after the two are done and if the params passed into the functions are the same or no.
	this.handler_format = function(cmd,value)	{
		var format = cmd.args[0].key, r;
		if(cmd.module == 'core' && this['format_'+format])	{
			r =this['format_'+format](value,cmd.args);
			}
		else if(cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based format. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core format specified");
			//invalid format specified.
			}
		return r;
		}

	this.format_currency = function(value,args)	{
		var r = value;
		if(args && args.length)	{
			var cur = this.pluckValue(args);
			r = "$"+value+" ("+cur+")";
			}
		return r;
		} //currency
	this.format_prepend = function(value,args)	{
		var r = value;
		if(args && args.length)	{
			var text = this.pluckValue(args);
			r = text+value;
			}
		return r;
		} //prepend
	this.format_append = function(value,args)	{
		var r = value;
		if(args && args.length)	{
			var text = this.pluckValue(args);
			r = value+text;
			}
		return r;
		} //append
	this.format_truncate = function(value,args)	{
		var r = value.toString(); //what is returned. Either original value passed in or a truncated version of it.
		if(args && args.length)	{
			var len = this.pluckValue(args);
			
			if(!len || isNaN(len)){}
			else if(r.length <= len){}
			else	{
				if (r.length > len) {
	/* Truncate the content of the string, then go back to the end of the previous word to ensure that we don't truncate in the middle of a word */
					r = r.substring(0, len);
					r = r.replace(/\w+$/, '');
	/* Add an ellipses to the end*/
					r += '...';
					}
				}
			}
		return r;
		} //truncate



/* //////////////////////////////     APPLY		 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */



//passing the command into this will verify that the apply exists (whether it be core or not)
//may be able to merge this with the handler_format. We'll see after the two are done and if the params passed into the functions are the same or no.
// NOTE -> stopped on 'apply' for now. B is going to change the way the grammer hands back the response. Once he does that, I'll need to flatten the array into a hash to easily test if 'empty' or some other verb is set.
	this.handler_apply = function($tag,cmd,binds,focusBind)	{
//		console.log(" -> BEGIN handler_apply"); //console.dir(cmd);
		var r = true;
		if(cmd.module == 'core')	{
			var cmdObj = this.args2obj(cmd.args); //an object is used to easily check if specific apply commands are present

			if(cmdObj.empty)	{$tag.empty()}
			if(cmdObj.hide)	{$tag.hide()}
			if(cmdObj.show)	{$tag.show()}
			if(cmdObj.remove)	{$tag.remove()}


//images get their own special handling.
			if(cmdObj.img)	{
				cmdObj._name = 'img'; //let the img handler know if it's img or imageurl. underscore is present in case a 'name' attribute is ever added to image.
				$tag = this.apply_img($tag,cmdObj,binds);
				}
			else	{

				if(cmdObj.imageurl)	{
					cmdObj._name = 'imageurl'; //let the img handler know if it's img or imageurl. underscore is present in case a 'name' attribute is ever added to image.
					binds[cmdObj.var] = this.apply_img($tag,cmdObj,binds); //function returns an image url
					}

				if(cmdObj.append)	{
	//				console.dir($tag);
					$tag.append(binds[focusBind]);
					}
				}
			
			}
		else if(cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based apply. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core apply specified");
			r = false;
			//invalid format specified.
			}
		return r;
		}



/*
#### TODO -> this isn't done 
needs to check if 'media' is set and if so, that starts the medialib code.
if not, check for src, which should be a file path.
if neither media or src, something is amiss.
This one block should get called for both img and imageurl but obviously, imageurl only returns the url.
*/
	this.apply_img = function($tag,cmdObj,binds)	{
		var r = true,filePath;
		console.dir(cmdObj);
		if(cmdObj.media && binds[cmdObj.media])	{
			console.log(" -> is mediaLib");
			//build filepath for media lib
			if(cmdObj.default)	{
				console.log(" -> use attributes of tag to build image path");
				//here need to check if default is set to a tag. not sure how, docs are not specific.
				if($tag.is('img'))	{
					cmdObj.mediaLibVars = {'width':$tag.attr('width'),'height':$tag.attr('height'),'data-bgcolor':$tag.data('bgcolor'),'data-minimal':$tag.data('minimal'),'data-filename':binds[cmdObj.media]};
					cmdObj.mediaLibVars.src = this.makeImageURL(cmdObj.mediaLibVars);
					}
				else	{
					r = false;
					//the command to pull attributes from the tag is invalid because the tag isn't an image.
					}
				}
			else	{
				console.log(" -> use cmdOjb to build image path");
				cmdObj.mediaLibVars = {'width':cmdObj.width,'height':cmdObj.height,'data-bgcolor':cmdObj.bgcolor,'data-minimal':cmdObj.minimal,'data-filename':binds[cmdObj.media]}
				cmdObj.mediaLibVars.src = this.makeImageURL(cmdObj.mediaLibVars);
				}
			}
		else if(cmdObj.src)	{
			//do nothing here, but is valid (don't get into 'else' error handling).
			}
		else	{
			r = false;
			//either media or src left blank. OR media is tru and the var specified doesn't exist. ### TODO -> handle this error.
			console.log(" -> either media ["+cmdObj.media+"] or src ["+cmdObj.src+"] not specified on appy img OR media is set but binds["+cmdObj.media+"] ["+binds[cmdObj.media]+"} is not.");
			}

		//to get here, the name is either imageurl or img.
		console.log(" -> cmdObj._name: "+cmdObj._name);
		//it's anticipated that _name == img on an img tag will be the highest use case for this.
		if($tag.is('img') && cmdObj._name == 'img')	{
			console.log(" -> img and img");
			$tag.attr(cmdObj.mediaLibVars);
			r = $tag;
			}
		else if(cmdObj._name == 'imageurl')	{r = filePath; console.log(' -> imageurl')}
		else	{
			if(cmdObj._name == 'img' && cmdObj.append)	{
				$tag.append($("<img>").attr(cmdObj.mediaLibVars));
				}
			if(cmdObj._name == 'img' && cmdObj.prepend)	{
				$tag.prepend($("<img>").attr(cmdObj.mediaLibVars));
				}
			r = $tag;
			}
		
		console.log(" -> _name: "+cmdObj._name+" r: "+r);
		return r;
		}





// NOTE - won't need this, everything will come in as 'longopt', even if no param is required.
//pass in the args array and this will return the value based on whether the input is a longopt or no.
	this.pluckValue = function(args)	{
		return (args[0].type == 'longopt' ? args[0].value.value : args[1].value);
		}


	this.args2string = function(args)	{
		var r = ""; //what is returned.
		for(var i = 0, L = args.length; i < L; i += 1)	{
			r += args[i]
			}
		return r;
		}
	


	this.handler_bind = function(cmd,vars)	{
//		console.log("Now we bind"); console.dir(cmd);
		//scalar type means get the value out of the data object.
		vars[cmd.args[0].value] = (cmd.args[1].type == 'scalar') ? jsonPath(this.data, cmd.args[1].value) : cmd.args[1].value;
		return cmd.args[0].value;
		}
	
	this.handler_datetime = function(cmd,value)	{
		var r; //what is returned.
		var d = new Date(value);
		if(isNaN(d.getMonth()+1))	{
			r = value; //what was originally passed into isn't recognized as a valid date 
			}
		else	{
			// NOT DONE YET
			}
		return r;
		}

	this.executeCommands = function($tag,commands)	{
//		console.log(" -> running peggyInstance.executeCommands");
		var
			binds = {}, //an object of all the binds set in args.
			tags = {
				'$tag' : $tag
				}, //an object of tags.
			focusBind, //the pointer to binds of the var currently in focus.
			focusTag; //the pointer to the tag that is currently in focus.

		for(var i = 0, L = commands.length; i < L; i += 1)	{
//			console.log(i+") commands[i]: "+commands[i].name); // console.dir(commands[i]);
			switch(commands[i].name)	{
				case "bind":
					focusBind = this.handler_bind(commands[i],binds);
					break;

				case "format":
					binds[focusBind] = this.handler_format(commands[i],binds[focusBind]);
					break;

				case "csss":
					// this will get ~tag '.bob' and we use that selector within $template context to set a new tag.
					//needs to add to the tags hash where key = value of ~tag (.bob) and value is the jquery object.
					break;

				case "apply" :
					try{
						this.handler_apply($tag,commands[i],binds,focusBind); //have to pass in all vars because things like 'media' delcare what var then need/want.
						}
					catch(err)	{
						console.error(err);
						}
					break;
				
				case "datetime":
					this.handler_datetime(commands[i]);
					break;

				default:
					console.log("Unrecognized command name ["+commands[i].name+"] -> no matching handler.");//  ### TODO -> what to do here?	
				}
			}
		}
	}


function makeTemplates()	{
	window.templates['someTemplate'] = $("#someTemplate").clone();
	window.templates['someOtherTemplate'] = $('#someOtherTemplate').clone();
	$("#someTemplate").empty().remove();
	$("#someOtherTemplate").empty().remove();
	}


function getRulesFromTextarea()	{
//	console.log(" -> getting rules from textarea");
	var success = false;
	try{
		var pegParserSource = PEG.buildParser($('#grammar').val());
		pegParser = eval(pegParserSource); //make sure pegParser is valid.
		success = true;
		}
	catch(e)	{
		console.warn("Could not build pegParser.");
		console.error(buildErrorMessage(e));
		}
	
	if(success)	{
		console.log(" -> successfully built pegParser");
//		translateTemplate();
		}
	}

/*
function getRules(rulesURL)	{
	console.log(' -> fetching rules: '+rulesURL);
	var rulesReq = $.ajax({
		url : rulesURL,
		dataType : 'text',
		error : function(a,b,c)	{
			console.warn("Got to the AJAX 'error'");
			console.log(a,b,c);
			},
		complete : function(a,b,c)	{
			console.log("Got to the AJAX 'complete'");
//			console.log(a,b,c);
			},
		success : function(data)	{
			console.log("Successfully fetched "+rulesURL);
			$('#grammar').val(data);
//			console.debug(data);
			var success = false;
			try{
				var pegParserSource = PEG.buildParser($('#grammar').val());
				pegParser = eval(pegParserSource);
				success = true;
				}
			catch(e)	{
				console.warn("Could not build pegParser.");
				console.log(buildErrorMessage(e));
				}
			
			if(success)	{
				console.log(" -> successfully built pegParser");
				translateTemplate();
				}
			}
		});
	}
*/



$(function() {
	console.log("Document is ready. Let's do stuff.");
	makeTemplates();
	getRulesFromTextarea('new_db_rules.pegjs');

	bob = new peggy('someTemplate',sampleProdData);
	frank = new peggy('someOtherTemplate',sampleProdData);
	$("#contentGoesHere").append(bob.translateTemplate());
	});
</script>
</head>
<body>

<div id='contentGoesHere' style='border:1px dashed #c00; padding:10px;'></div>
<br />
<!--
	<div data-bind="text(shipaddress2);"  title='address 2'></div>

	<span data-bind="text(shipcity);"  title='city'></span>
	<span data-bind="text(shipregion);"  title='state'></span>
	<span data-bind="text(shippostal);"  title='zip'></span>
	<div data-bind="text(shipcountrycode);" title='country'></div>
-->

<textarea id='grammar' rows='20' cols='50' style='display:none;'>
start
 = call+

call
 = grammar 

grammar
 = IfStatement _ lb*
 / BindStatement _ lb*
 / command:(command) _ lb* { return command }

command
 = _ module:([a-z_]+ "#")? cmd:[A-Za-z0-9?]+ args:((ws+ value)+)? _ lb* {
     return {
       type: "command",
       module: module || "core",
       name: cmd.join("").toLowerCase(),
       args: args ? args.map(function(a) { return a[1] }) : null
     }
   }


// ** BIND **
// bind $var 'something';    (jsonpath lookup)
// bind $var $someothervar;  (jsonpath lookup)
// bind $var ~tag;           (returns tag id/path)
// bind ~tag '#tagid';       jQuery('#tagid')
// bind ~tag $tagid          jQuery($tagid)
BindStatement
 = "bind" _ set:(variable tag) _ src:(variable / scalar tag) _ lb+ {
  return { type:"BIND", Set:set, Src:src } 
  }



IfStatement
  = "if" _ "(" _ condition:command _ ")" _ ifStatement:Block elseStatement:(_ "else" _ Block)? _ lb+ {
      return {
        type:     "IF",
        When:     condition,
        IsTrue:   ifStatement,
        IsFalse: elseStatement !== null ? elseStatement[3] : null
      };
   }


Block
  = "{{" _ statements:(StatementList _)? "}}" {
      return {
        type:       "Block",
        statements: statements !== null ? statements[0] : []
      };
    }

StatementList
  = head:Statement tail:(_ Statement)* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }

Statement
  = Block
  / command+
  



/* value types */

// ~tag is a reference to a jquery object
tag 
 = "~" tag:([a-zA-Z]+) {
   // tag table should maintain reference to tags on DOM
   return { type:"tag", tag:tag.join(""), jq:null }
   }

boolean 
 = "true" {return{ "type":"boolean", "value": true }}
 / "false" {return{ "type":"boolean", "value": false }}

// longopt start with a --
longopt
 = "--" k:([a-zA-Z]+) "=" v:( value )  {
    return {
       type: "longopt",
       key: k.join(""),
       value: v
       }
    }
 / "--" k:([a-zA-Z]+) {
    return {
      type: "longopt",
      key: k.join(""),
      value: null
      }
    }


// scalar (string)
// NOTE: at this point there is no way to escape a ' in a string.
// 
scalar
 = "'" v:([^']*) "'" {
     return { 
       type: "scalar",
       value: v.join("")
     } 
   }

// Variables can't start with a number
variable
 = "$" v:([a-zA-Z0-9_]*) { 
     return { 
       type: "variable",
       value: v.join("")
     } 
   }

integer
  = digits:[0-9]+ { 
      return { 
        type: "integer", 
        value: parseInt(digits.join(""), 10) 
      }
    }

hexcolor 
  = "#" v:([A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]) {
     return { type:"hexcolor", value: v.join("")  }
     }

additive
  = left:muldiv _ sign:[+-] _ right:additive { 
      return { 
        type: "command", 
        name:sign, 
        args:[left,right] 
      }
    }
  / muldiv

muldiv
  = left:primary _ sign:[*/] _ right:muldiv {
      return { 
        type: "command", 
        name: sign, 
        args:[left, right] 
      }
    }
  / primary

primary
  = (variable / integer)
  / "(" _ additive:additive _ ")" { return additive; }

value
 = longopt / variable / integer / scalar / boolean / tag / hexcolor / additive 

// /* i am a comment (i can only appear before a command) */
comment
  = "/*" (!"*/" SourceCharacter)* "*/" { return{}; }

SourceCharacter
  = .

ws
 = [ \t\n]

_
 = (ws / comment)*

lb
 = ";"
</textarea>





<div id='someTemplate' style='background:blue;'>
	<img data-tlc="bind $var '$.product.prod_image1'; apply --img --media=$var --width=100 --height=100 --bgcolor='#000000' --append;" />
	<h1 data-tlc="bind $var '$.product.name'; format --append=' - thats right! '; apply --append;">Lorem Ispsum Producismo Namola</h1>
	<h2 data-tlc="bind $var '$.product.base_price'; format --currency='USD';  format --prepend='price tag: '; apply --append;"></h2>
	<div data-tlc="bind $var '$.product.prod_desc'; format --truncate=250; apply --append;">default description</div>
</div>

<div id='someOtherTemplate' data-tlc="bind $var '$.product.prod_name'; tag --overwrite;" style='background:green;'>
	
	<h3 data-tlc="bind $var '$.product.prod_msrp'; tag --overwrite;">Lorem Ispsum Producismo Namola</h3>
	<img data-tlc="bind $var '$.product.prod_image1'; apply --img --media=$var --width=100 --height=100 --bgcolor='#000'  --append;" />
	<div data-tlc="bind $var '$.product.prod_desc'; tag --overwrite;"></div>
</div>





</body>
</html>
