<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Peggy</title>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type="text/javascript" src="peg-0.8.0.js"></script>
<script type="text/javascript" src="jsonpath.js"></script>

<script type='text/javascript'>

var templates = {};
var sampleProdData = {
		"%attribs" : {
			"name" : "This is a product name.",
			"base_price" : "5.23",
			"is_new" : "1",
			"is_four" : "4",
			"prod_hash"  : {'key':'value','anotherkey':'anothervalue'},
			"created" : 1391714080,
			"prod_image1" : "181657/24255646",
			"prod_msrp" : "",
			"prod_desc" : "Bacon ipsum dolor sit amet doner chicken ham hock swine meatball leberkas pancetta. Ham pastrami frankfurter brisket tail spare ribs pork chop rump beef ribs corned beef porchetta short ribs boudin capicola strip steak. Biltong jowl pork belly meatloaf jerky turkey. Bresaola strip steak andouille, porchetta turducken tongue ribeye ham pork chop. Kevin filet mignon strip steak brisket. Kevin turkey pastrami pork ham hock. Bacon ribeye beef ribs ham, shoulder swine flank strip steak pork chop prosciutto t-bone ground round."
			}
		}
var pegParser; //declared globally. this will be part of _app... most likely.

//here just for testing instances.
var bob; 
var frank;




/*

have a function for convert args to hash.
This will allow us to easily check to see if --empty AND --img (or any two verbs in apply) are set and to process them all.

NOTES -> a single CMD could have several formats in the args.  The args are gonna be condensed down into one hash per rule.
formats are processed in order.
apply is processed in a specific order. empty, then remove, then 'magic' (images, etc), then append/prepend/inner/etc.

*/



//creates an instance of the template, in memory.
//interpolates all data-tlc on that template.
//returns the template.
var peggy = function(templateID, data)	{
	console.log(" -> templateID: "+templateID);
	this.templateID = templateID;
	this.data = data;

//used w/ peg parser for tlc errors.
	this.buildErrorMessage = function(e) {
		return e.line !== undefined && e.column !== undefined ? "Line " + e.line + ", column " + e.column + ": " + e.message : e.message;
		}

//This is where the magic happens. Run this and the translated template will be returned.
	this.runTLC = function()	{
		var startTime = new Date().getTime(); console.log("BEGIN runTLC: "+startTime); // ### TESTING -> this is not necessary for deployment.
		
		var _self = this; //'this' context is lost within each loop.
		var $t = window.templates[templateID].clone();
//		console.log(" -> running peggyInstance.runTLC. data-tlc.length: "+$("[data-tlc]",$t).length);
		$("[data-tlc]",$t).addBack("[data-tlc]").each(function(index,value){
			var $tag = $(this), tlc = $tag.data('tlc');
//			console.log("----------------> start new $tag <-----------------");
			var commands = false;
			try{
				commands = window.pegParser.parse(tlc);
				}
			catch(e)	{
				console.log(self.buildErrorMessage(e));
				}

			if(commands && !$.isEmptyObject(commands))	{
				_self.executeCommands(commands,{
					tags : {
						'$tag' : $tag
						}, //an object of tags.
					focusTag : '$tag' //the pointer to the tag that is currently in focus.
					});
				}
			else	{
				console.warn("couldn't parse a tlc");
				//could not parse tlc. error already reported.
				}
//			console.log("----------------> end $tag <-----------------");
			});
		console.log("END runTLC: "+(new Date().getTime() - startTime)+" milliseconds");
		return $t;
		} //runTLC

//used in 'apply' and possibly elsewhere. changes the args arrays into a single object for easy lookup.
	this.args2obj = function(args)	{
		var r = {};
		for(var i = 0, L = args.length; i < L; i += 1)	{
			r[args[i].key] = (args[i].value == null) ? true : args[i].value; //some keys, like append or media, have no value and will be set to null.
			}
		return r;
		}

//The vars object should match up to what the attributes are on the image tag. It means the object used to create this instance can also be passed directly into a .attr()
	this.makeImageURL	= function(vars)	{
		if(vars['data-bgcolor'].charAt(0) == '#')	{vars['data-bgcolor'] = vars['data-bgcolor'].substr(1)}
		var url = (vars.width ? "-W"+vars.width : "")+(vars.height ? "-H"+vars.height : "")+(vars['data-bgcolor'] ? "-B"+vars['data-bgcolor'] : "")+(vars['data-minimal'] ? "-M" : "")+"/"+vars['data-filename']
		//don't want the first character to be a -. all params are optional, stripping first char is the most efficient way to build the path.
		return "http://www.sporks.zoovy.com/media/img/-/"+url.substr(1); //### TODO -> obviously, we don't want sporks info in URL.
		}

/*
This should return an img tag OR the url, based on whether the formatter is img or imageurl
'media' -> generate a media library instance for the var passed.
'src' -> use the value passed (/some/image/path.jpg)
The tag passed in will either be focusTag OR the $tag passed in.
	-> here, the tag can be used for read only purposes. The 'verb' handles updating the tag.
if neither media or src, something is amiss.
This one block should get called for both img and imageurl but obviously, imageurl only returns the url.
*/
	this.apply_formatter_img = function(formatter,$tag,argObj,globals)	{
		var r = true,filePath;
		argObj.media = argObj.media || {};
		var mediaParams;
		if(argObj.media.type == 'variable' && globals.binds[argObj.media.value])	{
			//build filepath for media lib
			//default = true is use focusTag. default = $tag says to use another, already defined, tag so focus shifts within this function, but focusTag does NOT change.
			if(typeof argObj.default === 'string')	{
				if(globals.tags[argObj.default])	{
					$tag = globals.tags[argObj.default]
					}
				else	{
					console.warn("Formatter img/imageurl specified "+argObj.default+" as the tag src, but that tag has not been defined");
					}
				}

			if(argObj.default)	{
				console.log(" -> use attributes of tag to build image path");
				//here need to check if default is set to a tag. not sure how, docs are not specific.
				if($tag.is('img'))	{
					mediaParams = {'width':$tag.attr('width'),'height':$tag.attr('height'),'data-bgcolor':$tag.data('bgcolor'),'data-minimal':$tag.data('minimal'),'data-filename':globals.binds[argObj.media]};
					filePath = this.makeImageURL(mediaParams);
					}
				else	{
					r = false;
					//the command to pull attributes from the tag is invalid because the tag isn't an image.
					}
				}
			else	{
				mediaParams = {'width':argObj.width.value,'height':argObj.height.value,'data-bgcolor':argObj.bgcolor.value,'data-minimal':(argObj.minimal ? argObj.minimal.value : 0),'data-filename':globals.binds[argObj.media.value]};
				filePath = this.makeImageURL(mediaParams);
				}
			}
		else if(argObj.src && argObj.src.value)	{
			//do nothing here, but is valid (don't get into 'else' error handling).
			}
		else	{
			r = false;
			//either media or src left blank. OR media is tru and the var specified doesn't exist.
			console.log("Something was missing for apply_img.\if media.type == 'variable' then globals.binds[argObj.media.value] must be set.\nor src ["+argObj.src+"] not specified on appy img OR media is set but globals.binds["+argObj.media+"] ["+globals.binds[argObj.media]+"} is not.");
			}

		if(filePath && formatter == 'img')	{
			var $tmp = $("<div \/>").append($("<img \/>").attr(mediaParams).attr('src',filePath));
			r = $tmp.html();
			}
		else if(filePath)	{
			r = filePath;
			}
		else	{} //some error occured. should have already been written to console by now.

		return r;
		}
	
	this.apply_verb_select = function($tag,argObj,globals)	{
		var dataValue = globals.binds[globals.focusBind]; //shortcut.
		if($tag.is(':checkbox'))	{
			if(dataValue == "" || Number(dataValue) === 0)	{
				$tag.prop({'checked':false,'defaultChecked':false}); //have to handle unchecking in case checked=checked when template created.
				}
			else	{
//the value here could be checked, on, 1 or some other string. if the value is set (and we won't get this far if it isn't), check the box.
				$tag.prop({'checked':true,'defaultChecked':true});
				}
			}
		else if($tag.is(':radio'))	{
//with radio's the value passed will only match one of the radios in that group, so compare the two and if a match, check it.
			if($tag.val() == dataValue)	{$tag.prop({'checked':true,'defaultChecked':true})}
			}
		else if($tag.is('select') && $tag.attr('multiple') == 'multiple')	{
			if(typeof dataValue === 'object')	{
				var L = dataValue.length;
				for(var i = 0; i < L; i += 1)	{
					$('option[value="' + dataValue[i] + '"]',$tag).prop({'selected':'selected','defaultSelected':true});
					}
				}
			}
		else	{
			$tag.val(dataValue);
			$tag.prop('defaultValue',dataValue); //allows for tracking the difference onblur.
			}
		}

	this.handle_apply_verb = function(verb,$tag,argObj,globals){
		switch(verb)	{
//new Array('empty','hide','show','add','remove','prepend','append','replace','input-value','select','state','attrib'),
			case 'empty': $tag.empty(); break;
			case 'hide': $tag.hide(); break;
			case 'show': $tag.show(); break;

			//add and remove work w/ either 'tag' or 'class'.
			case 'add' : 
				if(argObj.class)	{$tag.addClass(argObj.class)}
				else if(argObj.tag)	{
					// ### TODO -> not done yet. what to do? add a tag? what tag? where does it come from?
					}
				break; 
			case 'remove':
				if(argObj.class)	{$tag.removeClass(argObj.class)}
				else if(argObj.tag)	{
					$tag.remove();
					}
				else	{
					console.warn("For apply, the verb was set to remove, but neither a tag or class were defined. argObj follows:"); console.dir(argObj);
					}
				break; 
			
			case 'prepend': $tag.prepend(globals.binds[globals.focusBind]); break;
			case 'append': $tag.append(globals.binds[globals.focusBind]); break;
			case 'replace': $tag.replaceWith(globals.binds[globals.focusBind]); break;
			case 'input-value':
				$tag.val(globals.binds[globals.focusBind]);
				break;
			case 'select' :
				this.apply_verb_select($tag,argObj,globals); //will modify $tag.
				break;
			case 'state' :
				// ### TODO -> not done yet.
				break;  
			case 'attrib':
				$tag.attr(argObj.attrib.value,globals.binds[globals.focusBind]);
				break;
			}
		}

	this.handle_apply_formatter = function(formatter,$tag,argObj,globals)	{
		switch(formatter)	{
			case 'text':
				if(globals.binds[argObj.text])	{
					var $tmp = $("<div>").append(globals.binds[argObj.text]);
					globals.binds[argObj.text] = $tmp.text();
					globals.focusBind = argObj.text;
					}
				else	{
					console.warn("For command "+cmd+" formatter set to text but scalar passed is not defined in globals.binds");
					}
				break;
			case 'html':
				globals.focusBind = argObj.html;
				break;
			case 'img':
				globals.binds[globals.focusBind] = this.apply_formatter_img(formatter,$tag,argObj,globals);
				break;
			case 'imageurl':
				globals.binds[globals.focusBind] = this.apply_formatter_img(formatter,$tag,argObj,globals); //function returns an image url
				break;
			}
		}

	this.comparison = function(op,p1,p2)	{
		var r = false;
		switch(op)	{
			case "eq":
				if(p1 == p2){ r = true;} break;
			case "ne":
				if(p1 != p2){ r = true;} break;
			case "gt":
				if(Number(p1) > Number(p2)){r = true;} break;
			case "lt":
				if(Number(p1) < Number(p2)){r = true;} break;
			case "true":
				if(p1){r = true;}; break;
			case "false":
				if(!p1){r = true;}; break;
			case "blank":
				if(p1 == ''){r = true;}; break;
			case "notblank":
				if(!p1 || p1 == 0){r = true;}; break; //==, not ===, because zero could be passed in as a string.
			case "null":
				if(p1 == null){r = true;}; break;
			case "notnull":
				if(p1 != null){r = true;}; break;
			case "regex":
				var regex = new RegExp(p2);
				if(regex.exec(p1))	{r = true;}
				break;
			case "notregex":
				var regex = new RegExp(p2);
				if(!regex.exec(p1))	{r = true;}
				break;
// and/or allow commands to be chained.
//--and (FUTURE) -> this is for chaining, so if and is present, 1 false = IsFalse.
//--or (FUTURE) -> this is for chaining, so if and is present, 1 true = IsTrue.
/*			case "and":
				if(p1 != null){r = true;}; break; // ### FUTURE -> not done
			case "or":
				if(p1 != null){r = true;}; break; // ### FUTURE -> not done.
*/			}
		return r;
		}



/* //////////////////////////////     FORMATS	 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */

//passing the command into this will verify that the format exists (whether it be core or not)

	this.format_currency = function(arg,globals)	{
		var r = "$"+globals.binds[globals.focusBind]+" ("+arg.value.value+")";
		globals.binds[globals.focusBind] = r
		return r;
		} //currency
	this.format_prepend = function(arg,globals)	{
		var r = arg.value.value+globals.binds[globals.focusBind];
		globals.binds[globals.focusBind] = r
		return r;
		} //prepend
	this.format_append = function(arg,globals)	{
		var r = globals.binds[globals.focusBind]+arg.value.value;
		globals.binds[globals.focusBind] = r
		return r;
		} //append
	this.format_truncate = function(arg,globals)	{
		var
			r = globals.binds[globals.focusBind].toString(), //what is returned. Either original value passed in or a truncated version of it.
			len = arg.value.value;
		if(!len || isNaN(len)){}
		else if(r.length <= len){}
		else	{
			if (r.length > len) {
				r = r.substring(0, len); //Truncate the content of the string
				r = $.trim(r.replace(/\w+$/, '')); //go back to the end of the previous word to ensure that we don't truncate in the middle of a word. trim trailing whitespace.
				r += '&#8230;'; //Add an ellipses to the end
				globals.binds[globals.focusBind] = r;
				}
			}
		return r;
		} //truncate
	this.format_uriencode = function(arg,globals)	{
		var r = encodeURI(globals.binds[globals.focusBind]);
		globals.binds[globals.focusBind] = r
		return r;
		} //truncate



/* //////////////////////////////     TYPE HANDLERS		 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */

/*
There are a few 'types' that can be specified:
BIND (setting a var)
IF (conditional logic) 
Block (set for the statements inside an IF IsTrue or IsFalse). contains an array of statements.
command (everything else that's supported).
*/

	this.handleType_command = function(cmd,globals)	{
//		console.log(" -> cmd.name: "+cmd.name); // console.dir(cmd);
		try{
			this['handleCommand_'+cmd.name](cmd,globals);
			}
		catch(e){
//			console.error("Attempted to execute a handler for "+cmd.name+", which either does not exist or resulted in an error.");
			console.log(e);
			console.dir(cmd);
			}
		}

	this.handleType_BIND = function(cmd,globals)	{
//		console.log("Now we bind"); console.dir(cmd);
		//scalar type means get the value out of the data object.
		globals.binds[cmd.Set.value] = (cmd.Src.type == 'scalar') ? jsonPath(this.data, '$'+cmd.Src.value) : cmd.Src.value;
		globals.focusBind = cmd.Set.value; // console.log(" -> globals.focusBind: "+globals.focusBind);
		return cmd.Set.value;
		}
	
	this.handleType_IF = function(cmd,globals)	{
//		console.log("BEGIN handleIF"); console.dir(cmd);
		var p1; //first param for comparison.
		var args = cmd.When.args;
		var action = 'IsTrue'; //will be set to false on first false (which exits loop);
		//NOTE -> change '2' to args.length to support multiple args. ex: if (is $var --lt='100' --gt='5') {{ apply --append; }};
		for(var i = 0, L = 2; i < L; i += 1)	{
			if(args[i].type == 'variable')	{
				p1 = globals.binds[args[i].value];
				}
			else	{
				if(this.comparison(args[i].key,p1,(args[i].value && args[i].value) ? args[i].value.value : null))	{}
				else {
					action = 'IsFalse';
					break;
					}
				}
			}
		if(cmd[action])	{
//			console.log(' -> cmd[action]'); console.dir(cmd[action].statements[0]);
			for(var i = 0, L = cmd[action].statements[0].length; i < L; i += 1)	{
				this.executeCommands(cmd[action].statements[0][i],globals); // ### TODO -> the statements are being returned nested 1 level deep in an otherwise empty array. bug.
				}
			
			}
		else	{} //would get here if NOT true, but no isFalse was set. I guess technically you could also get here if isTrue and no isTrue set.
		return (action == 'isTrue' ? true : false);
		}




/* //////////////////////////////     COMMAND HANDLERS		 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */

	this.handleCommand_format = function(cmd,globals)	{
		var format = cmd.args[0].key, r;
//		console.log(' -> cmd: '); console.dir(cmd);
		if(cmd.module == 'core' && this['format_'+format])	{
			for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
				try	{
					this['format_'+cmd.args[i].key](cmd.args[i],globals);
					}
				catch(e)	{}
				}
			}
		else if(cmd.module && cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based format. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core format specified");
			//invalid format specified.
			}
		return r;
		}

//passing the command into this will verify that the apply exists (whether it be core or not)
//may be able to merge this with the handleCommand_format. We'll see after the two are done and if the params passed into the functions are the same or no.
// NOTE -> stopped on 'apply' for now. B is going to change the way the grammer hands back the response. Once he does that, I'll need to flatten the array into a hash to easily test if 'empty' or some other verb is set.
	this.handleCommand_apply = function(cmd,globals)	{
//		console.log(" -> BEGIN handleCommand_apply");// console.dir(cmd);
		var r = true;
		if(cmd.module == 'core')	{
			var
				verbs = new Array('empty','hide','show','add','remove','prepend','append','replace','input-value','select','state','attrib'),
				formatters = new Array('img','imageurl','text','html'),
				argObj = this.args2obj(cmd.args), //an object is used to easily check if specific apply commands are present
				$tag = globals.tags[(argObj.tag || globals.focusTag)],
				numVerbs = 0, numFormatters = 0, theVerb = null, theFormatter = null;

			//count the number of verbs.  Only 1 is allowed.
			for(var index in argObj)	{
				if($.inArray(index,verbs) >= 0)	{
					theVerb = index;
					numVerbs++;
					}
				else if($.inArray(index,formatters) >= 0)	{
					theFormatter = index;
					numFormatters++;
					}
				else	{
					//okay to get here. likely just some argument for the verb or formatter
					}
				}
			
//			console.log("numVerbs: "+numVerbs+" theVerb: "+theVerb+" theFormat: "+theFormatter+" numFormats: "+numFormatters);
			//formatter is optional, but only 1 can be specified.
			if(numVerbs === 1 && numFormatters <= 1)	{

				if(theFormatter)	{
//					console.log(" -> a formatter ["+theFormatter+"] is set. process that first.");
					this.handle_apply_formatter(theFormatter,$tag,argObj,globals);
					}
				
				this.handle_apply_verb(theVerb,$tag,argObj,globals);

				}
			else if(numVerbs === 0)	{
				console.warn("For command: "+cmd+" no verb was specified on the apply. Exactly 1 verb must be specified.");
				}
			else	{
				console.warn("For command (below) either more than 1 verb or more than 1 formatter was specified on the apply. Exactly 1 of each is allowed per command.");
				console.dir(cmd);
				}

			}
		else if(cmd.module && cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based apply. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core apply specified");
			r = false;
			//invalid format specified.
			}
		return r;
		}

	
	this.handleCommand_render = function(cmd,globals){
		var r, argObj = this.args2obj(cmd.args); //an object is used to easily check if specific apply commands are present
//		console.log(" -> cmd: "); console.dir(cmd);
		if(argObj.wiki)	{
			var $tmp = $("<div>").append(value);
			//r = wikify($tmp.text()); //###TODO -> 
			globals.binds[cmd.Set.value] = $tmp.text();
			}
		else if(argObj.html)	{
			r = value; //if the content is already html, shouldn't have to do anything to it.
			}
		else if(argObj.dwiw)	{
			// ###TODO -> need to determine if content is wiki or html.
			r = value;
			}
		else	{
			//unrecognized command.
			r = value;
			}
		return r;
		}
		
	this.handleCommand_stringify = function(cmd,globals)	{
		globals.binds[globals.focusBind] = JSON.stringify(globals.binds[globals.focusBind])
		return globals.binds[globals.focusBind];
		}

	this.handleCommand_transmogrify = function(cmd,globals)	{
//		console.log(" ->>>>>>> templateID: "+cmd.args[0].value); //console.dir(this.args2obj(cmd.args));
		var tmp = new peggy(cmd.args[0].value,this.data);
		globals.tags[globals.focusTag].append(tmp.runTLC());
		//this will backically instantate a new peggy (or whatever it's called)
		}

	this.handleCommand_is = function(cmd,globals)	{
		var value = globals.binds[globals.focusBind], r = false;
		for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
			value = this.comparison(cmd.args[i].key,value,cmd.args[i].value.value);
			}
		globals.binds[globals.focusBind] = value;
		return value;
		}

	this.handleCommand_math = function(cmd,globals)	{
		var value = Number(globals.binds[globals.focusBind]);
		if(!isNaN(value))	{
			for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
				switch(cmd.args[i].key)	{
					case "add":
						value += cmd.args[i].value.value; break;
					case "sub":
						value -= cmd.args[i].value.value; break;
					case "mult":
						value *= cmd.args[i].value.value; break;
					case "div":
						value /= cmd.args[i].value.value; break;
					case "precision":
						value = value.toFixed(cmd.args[i].value.value); break;
					case "percent":
						value = (value/100).toFixed(0); break;
					}
				}
			globals.binds[globals.focusBind] = value;
			}
		else	{
			console.log(" -> handleCommand_math was run on a value ["+globals.binds[globals.focusBind]+" which is not a number.");
			}
		return value;
		}

	this.handleCommand_datetime = function(cmd,globals)	{

		var value = globals.binds[globals.focusBind];
		var argObj = this.args2obj(cmd.args), d = new Date(value*1000);


		if(isNaN(d.getMonth()+1))	{
			console.warn("In handleCommand_datetime, value ["+value+"] is not a valid time format for Date()");
			}
//### FUTURE
//		else if(argObj.out-strftime)	{}
		else if (argObj.out.value == 'pretty')	{
			var shortMon = new Array('Jan','Feb','Mar','Apr','May','June','July','Aug','Sep','Oct','Nov','Dec');
			value = (shortMon[d.getMonth()])+" "+d.getDate()+" "+d.getFullYear()+ " "+d.getHours()+":"+((d.getMinutes()<10?'0':'') + d.getMinutes());
			}
		else if(argObj.out.value == 'mdy')	{
			value = (d.getMonth()+1)+"/"+d.getDate()+"/"+d.getFullYear();
			}
		else	{
			//invalid or no 'out' specified.
			}
		globals.binds[globals.focusBind] = value;
		return value;
		}


//can be triggered by runTLC OR by handleType_Block.
	this.executeCommands = function(commands,globals)	{
//		console.log(" -> running peggyInstance.executeCommands"); // console.dir(commands);
		//make sure all the globals are defined. whatever is passed in will overwrite the defaults.
		var theseGlobals = $.extend(true,{
			binds : {}, //an object of all the binds set in args.
			tags : {
				'$tag' : ''
				}, //an object of tags.
			focusBind : '', //the pointer to binds of the var currently in focus.
			focusTag : '$tag' //the pointer to the tag that is currently in focus.
			},globals);

		for(var i = 0, L = commands.length; i < L; i += 1)	{
//			console.log(i+") commands[i]: handleCommand_"+commands[i].type); //console.dir(commands[i]);
			if(commands[i].type == 'command')	{
				this.handleType_command(commands[i],theseGlobals);
				}
			else if(commands[i].type == 'IF')	{
				this['handleType_IF'](commands[i],theseGlobals);
				}
			else if(commands[i].type == 'BIND')	{
				this['handleType_BIND'](commands[i],theseGlobals);
				}
			else	{
				//unrecognized type.
				}

			}
		}
	}


function makeTemplates()	{
	window.templates['someTemplate'] = $("#someTemplate").clone();
	window.templates['someOtherTemplate'] = $('#someOtherTemplate').clone();
	$("#someTemplate").empty().remove();
	$("#someOtherTemplate").empty().remove();
	}


function getRulesFromTextarea()	{
//	console.log(" -> getting rules from textarea");
	var success = false;
	try{
		var pegParserSource = PEG.buildParser($('#grammar').val());
		pegParser = eval(pegParserSource); //make sure pegParser is valid.
		success = true;
		}
	catch(e)	{
		console.warn("Could not build pegParser.");
		console.error(buildErrorMessage(e));
		}
	
	if(success)	{
		console.log(" -> successfully built pegParser");
//		runTLC();
		}
	}

/*
function getRules(rulesURL)	{
	console.log(' -> fetching rules: '+rulesURL);
	var rulesReq = $.ajax({
		url : rulesURL,
		dataType : 'text',
		error : function(a,b,c)	{
			console.warn("Got to the AJAX 'error'");
			console.log(a,b,c);
			},
		complete : function(a,b,c)	{
			console.log("Got to the AJAX 'complete'");
//			console.log(a,b,c);
			},
		success : function(data)	{
			console.log("Successfully fetched "+rulesURL);
			$('#grammar').val(data);
//			console.debug(data);
			var success = false;
			try{
				var pegParserSource = PEG.buildParser($('#grammar').val());
				pegParser = eval(pegParserSource);
				success = true;
				}
			catch(e)	{
				console.warn("Could not build pegParser.");
				console.log(buildErrorMessage(e));
				}
			
			if(success)	{
				console.log(" -> successfully built pegParser");
				runTLC();
				}
			}
		});
	}
*/



$(function() {
	console.log("Document is ready. Let's do stuff.");
	makeTemplates();
	getRulesFromTextarea(); //'new_db_rules.pegjs'

	bob = new peggy('someTemplate',sampleProdData);
//	frank = new peggy('someOtherTemplate',sampleProdData);
	$("#contentGoesHere").append(bob.runTLC());
	});
</script>
</head>
<body>

<div id='contentGoesHere' style='border:1px dashed #c00; padding:10px;'></div>
<br />
<!--
	<div data-bind="text(shipaddress2);"  title='address 2'></div>

	<span data-bind="text(shipcity);"  title='city'></span>
	<span data-bind="text(shipregion);"  title='state'></span>
	<span data-bind="text(shippostal);"  title='zip'></span>
	<div data-bind="text(shipcountrycode);" title='country'></div>
-->

<textarea id='grammar' rows='20' cols='50' style='display:none;'>
dataTLC
 = grammar+

grammar
 = cmd:(IfStatement) _ lb* { return cmd; }
 / cmd:(BindStatement) _ lb* { return cmd; } 
 / cmd:(command) _ lb* { return cmd; }

command
 = _ module:([a-z_]+ "#")? cmd:[a-z?]+ args:((ws+ value)+)? _ lb* {
     return {
       type: "command",
       module: module ? module[0].join("") : "core",
       name: cmd.join("").toLowerCase(),
       args: args ? args.map(function(a) { return a[1] }) : null
     }
   }


// ** BIND **
// bind $var 'something'; (jsonpath lookup)
// bind $var $someothervar; (jsonpath lookup)
// bind $var ~tag; (returns tag id/path)
// bind ~tag '#tagid'; jQuery('#tagid')
// bind ~tag $tagid jQuery($tagid)
BindStatement
 = "bind" _ set:(variable / tag) _ src:(variable / scalar / tag) _ lb+ {
  return { type:"BIND", Set:set, Src:src }
  }



IfStatement
  = "if" _ "(" _ condition:command _ ")" _ ifStatement:Block elseStatement:(_ "else" _ Block)? _ lb+ {
      return ({
        type: "IF",
        When: condition,
        IsTrue: ifStatement,
        IsFalse: elseStatement !== null ? elseStatement[3] : null
      });
   }


Block
  = "{{" _ statements:(StatementList _)? "}}" {
      return {
        type: "Block",
        statements: statements !== null ? statements : []
      };
    }

StatementList
  = head:Statement tail:(_ Statement)* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }

Statement
  = Block
  / command+
  



/* value types */

// ~tag is a reference to a jquery object
tag
 = "~" tag:([a-zA-Z]+) {
   // tag table should maintain reference to tags on DOM
   return { type:"tag", tag:tag.join(""), jq:null }
   }

boolean
 = "true" {return{ "type":"boolean", "value": true }}
 / "false" {return{ "type":"boolean", "value": false }}

// longopt start with a --
longopt
 = "--" k:([a-zA-Z]+) "=" v:( value ) {
    return {
       type: "longopt",
       key: k.join(""),
       value: v
       }
    }
 / "--" k:([a-zA-Z]+) {
    return {
      type: "longopt",
      key: k.join(""),
      value: null
      }
    }


// scalar (string)
// NOTE: at this point there is no way to escape a ' in a string.
//
scalar
 = "'" v:([^']*) "'" {
     return {
       type: "scalar",
       value: v.join("")
     }
   }

// Variables can't start with a number
variable
 = "$" v:([a-zA-Z0-9_]*) {
     return {
       type: "variable",
       value: v.join("")
     }
   }

integer
  = digits:[0-9]+ {
      return {
        type: "integer",
        value: parseInt(digits.join(""), 10)
      }
    }

hexcolor
  = "#" v:([A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]) {
     return { type:"hexcolor", value: v.join("") }
     }

additive
  = left:muldiv _ sign:[+-] _ right:additive {
      return {
        type: "command",
        name:sign,
        args:[left,right]
      }
    }
  / muldiv

muldiv
  = left:primary _ sign:[*/] _ right:muldiv {
      return {
        type: "command",
        name: sign,
        args:[left, right]
      }
    }
  / primary

primary
  = (variable / integer)
  / "(" _ additive:additive _ ")" { return additive; }

value
 = longopt / variable / integer / scalar / boolean / tag / hexcolor / additive

// /* i am a comment (i can only appear before a command) */
comment
  = "/*" (!"*/" SourceCharacter)* "*/" { return{}; }

SourceCharacter
  = .

ws
 = [ \t\n]

_
 = (ws / comment)*

lb
 = ";"
</textarea>


<div id='someTemplate'>

	<img data-tlc="bind $var '.%attribs.prod_image1'; apply --img --media=$var --width=100 --height=100 --bgcolor='#000000' --replace;" />
	<h1 data-tlc="bind $var '.%attribs.name'; format --append=' - thats right! '; apply --append;"></h1>
	<h2 data-tlc="bind $var '.%attribs.base_price'; format --currency='USD';  format --prepend='price tag: '; apply --append;"></h2>
	<h5 data-tlc="bind $var '.%attribs.base_price'; math --add=20 --sub=10 --precision=0 --mult=3; format --currency='USD';  format --prepend='Fake msrp: '; apply --append;"></h5>
	<h3 data-tlc="bind $var '.%attribs.created'; datetime --out='pretty'; apply --append;"></h3><br />

	<section data-tlc="transmogrify 'someOtherTemplate';"></section>

	<div data-tlc="bind $var '.%attribs.prod_desc'; format --truncate=250; apply --append;"></div><br />
	<div data-tlc="bind $var '.%attribs.prod_hash'; stringify $var; apply --append;">Stringify: </div>
	<div data-tlc="bind $var '.%attribs.base_price'; apply --attrib='data-garbage';">should have data-garbage set</div>
	
	<div data-tlc="bind $var '.%attribs.base_price';if (is $var --lt='100' --gt='2') {{ apply --show; }};"></div>
	<div style='display:none;' data-tlc="bind $var '.%attribs.is_new';if (is $var --eq='1') {{ apply --show; }};">This should be visible</div>
	<div style='display:none;' data-tlc="bind $var '.%attribs.is_new';if (is $var --ne='2') {{ apply --hide; }};">This should be hidden</div>

	<fieldset>
		<legend>Checkbox testing</legend>
		<div><input type='checkbox'  data-tlc="bind $var '.%attribs.is_four'; apply --select;" name='checkbox' />This is a checkbox (should be checked)</div>
		<div><input type='checkbox'  data-tlc="bind $var '.%attribs.is_nada'; apply --select;" checked="checked" name='checkbox' />This is a checkbox (should NOT be checked)</div>
	</fieldset>

	<fieldset>
		<legend>All these inputs should be set to 4</legend>
	<select name='alfred' data-tlc="bind $var '.%attribs.is_four'; apply ~tag --select;">
		<option value='1'>1</option>
		<option value='2'>2</option>
		<option value='3'>3</option>
		<option value='4'>4</option>
		<option value='5'>5</option>
		<option value='6'>6</option>
	</select>
	<br />
	

	<div><input type='text'  data-tlc="bind $var '.%attribs.is_four'; apply ~tag --select;" name='textInput' size='3' />Text input</div>
	
	<br />
	
	<div><input type='radio' name='something' value='2' data-tlc="bind $var '.%attribs.is_four'; apply ~tag --select;" />two</div>
	<div><input type='radio' name='something' value='4' data-tlc="bind $var '.%attribs.is_four'; apply ~tag --select;" />four</div>
	<div><input type='radio' name='something' value='6' data-tlc="bind $var '.%attribs.is_four'; apply ~tag --select;" />six</div>
	</fieldset>
</div>

<div id='someOtherTemplate' style='background-color:green;'>
	HELLO WORLD!
	<div data-tlc="bind $var '.%attribs.prod_desc'; format --truncate=250; apply --append;"></div><br />
</div>





</body>
</html>
