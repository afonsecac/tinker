<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Peggy</title>

<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type="text/javascript" src="peg-0.8.0.js"></script>
<script type="text/javascript" src="jsonpath.js"></script>

<script type='text/javascript'>

var templates = {};
var sampleProdData = {
		"product" : {
			"name" : "This is a product name.",
			"base_price" : "5.23",
			"is_new" : "1",
			"prod_hash"  : {'key':'value','anotherkey':'anothervalue'},
			"created" : 1391714080,
			"prod_image1" : "181657/24255646",
			"prod_msrp" : "",
			"prod_desc" : "Bacon ipsum dolor sit amet doner chicken ham hock swine meatball leberkas pancetta. Ham pastrami frankfurter brisket tail spare ribs pork chop rump beef ribs corned beef porchetta short ribs boudin capicola strip steak. Biltong jowl pork belly meatloaf jerky turkey. Bresaola strip steak andouille, porchetta turducken tongue ribeye ham pork chop. Kevin filet mignon strip steak brisket. Kevin turkey pastrami pork ham hock. Bacon ribeye beef ribs ham, shoulder swine flank strip steak pork chop prosciutto t-bone ground round."
			}
		}
var pegParser; //declared globally. this will be part of _app... most likely.

//here just for testing instances.
var bob; 
var frank;




/*

have a function for convert args to hash.
This will allow us to easily check to see if --empty AND --img (or any two verbs in apply) are set and to process them all.

NOTES -> a single CMD could have several formats in the args.  The args are gonna be condensed down into one hash per rule.
formats are processed in order.
apply is processed in a specific order. empty, then remove, then 'magic' (images, etc), then append/prepend/inner/etc.

*/



//creates an instance of the template, in memory.
//interpolates all data-tlc on that template.
//returns the template.
var peggy = function(templateID, data)	{

	this.templateID = templateID;
	this.data = data;

//used w/ peg parser for tlc errors.
	this.buildErrorMessage = function(e) {
		return e.line !== undefined && e.column !== undefined ? "Line " + e.line + ", column " + e.column + ": " + e.message : e.message;
		}
//This is where the magic happens. Run this and the translated template will be returned.
	this.translateTemplate = function()	{
		var _self = this; //'this' context is lost within each loop.
		var $t = window.templates[templateID].clone();
//		console.log(" -> running peggyInstance.translateTemplate. data-tlc.length: "+$("[data-tlc]",$t).length);
		$("[data-tlc]",$t).addBack("[data-tlc]").each(function(index,value){
			var $tag = $(this), tlc = $tag.data('tlc');
			console.log("----------------> start new $tag <-----------------");
			var commands = false;
			try{
				commands = window.pegParser.parse(tlc);
				}
			catch(e)	{
				console.log(self.buildErrorMessage(e));
//				console.log("attempt to run parse on "+tlc+" failed w/ the following error(s):");
				}

			if(commands && !$.isEmptyObject(commands))	{
				_self.executeCommands($tag,commands);
				}
			else	{
				console.warn("couldn't parse a tlc");
				//could not parse tlc. error already reported.
				}
			console.log("----------------> end $tag <-----------------");
			});
		return $t;
		} //translateTemplate

//used in 'apply' and possibly elsewhere. changes the args arrays into a single object for easy lookup.
	this.args2obj = function(args)	{
		var r = {};
		for(var i = 0, L = args.length; i < L; i += 1)	{
			r[args[i].key] = (args[i].value == null) ? true : args[i].value; //some keys, like append or media, have no value and will be set to null.
			}
		return r;
		}

//The vars object should match up to what the attributes are on the image tag. It means the object used to create this instance can also be passed directly into a .attr()
	this.makeImageURL	= function(vars)	{
		if(vars['data-bgcolor'].charAt(0) == '#')	{vars['data-bgcolor'] = vars['data-bgcolor'].substr(1)}
		var url = (vars.width ? "-W"+vars.width : "")+(vars.height ? "-H"+vars.height : "")+(vars['data-bgcolor'] ? "-B"+vars['data-bgcolor'] : "")+(vars['data-minimal'] ? "-M" : "")+"/"+vars['data-filename']
		//don't want the first character to be a -. all params are optional, stripping first char is the most efficient way to build the path.
		return "http://www.sporks.zoovy.com/media/img/-/"+url.substr(1); //### TODO -> obviously, we don't want sporks info in URL.
		}



/*
//apply_img is executed in the apply_handler.
'media' -> generate a media library instance for the var passed.
'src' -> use the value passed (/some/image/path.jpg)

img
if neither media or src, something is amiss.
This one block should get called for both img and imageurl but obviously, imageurl only returns the url.
*/
	this.apply_img = function($tag,argObj,binds)	{
		var r = true,filePath;
		argObj.media = argObj.media || {};
		if(argObj.media.type == 'variable' && binds[argObj.media.value])	{
			//build filepath for media lib
			if(argObj.default)	{
				console.log(" -> use attributes of tag to build image path");
				//here need to check if default is set to a tag. not sure how, docs are not specific.
				if($tag.is('img'))	{
					argObj.mediaLibVars = {'width':$tag.attr('width'),'height':$tag.attr('height'),'data-bgcolor':$tag.data('bgcolor'),'data-minimal':$tag.data('minimal'),'data-filename':binds[argObj.media]};
					argObj.mediaLibVars.src = this.makeImageURL(argObj.mediaLibVars);
					}
				else	{
					r = false;
					//the command to pull attributes from the tag is invalid because the tag isn't an image.
					}
				}
			else	{
				argObj.mediaLibVars = {'width':argObj.width.value,'height':argObj.height.value,'data-bgcolor':argObj.bgcolor.value,'data-minimal':(argObj.minimal ? argObj.minimal.value : 0),'data-filename':binds[argObj.media.value]}
				argObj.mediaLibVars.src = this.makeImageURL(argObj.mediaLibVars);
				}
			}
		else if(argObj.src && argObj.src.value)	{
			//do nothing here, but is valid (don't get into 'else' error handling).
			}
		else	{
			r = false;
			//either media or src left blank. OR media is tru and the var specified doesn't exist. ### TODO -> handle this error.
//			console.log("Something was missing for apply_img.\if media.type ["+argObj.media.type+"] == 'variable' then binds[argObj.media.value] ["+binds[argObj.media.value]+"] must be set.\nor src ["+argObj.src+"] not specified on appy img OR media is set but binds["+argObj.media+"] ["+binds[argObj.media]+"} is not.");
			}

		//to get here, the name is either imageurl or img.
//		console.log(" -> argObj._name: "+argObj._name);
		//it's anticipated that _name == img on an img tag will be the highest use case for this.
		if($tag.is('img') && argObj._name == 'img')	{
			$tag.attr(argObj.mediaLibVars);
			r = $tag;
			}
		else if(argObj._name == 'imageurl')	{r = filePath; console.log(' -> imageurl')}
		else	{
			if(argObj._name == 'img' && argObj.append)	{
				$tag.append($("<img>").attr(argObj.mediaLibVars));
				}
			if(argObj._name == 'img' && argObj.prepend)	{
				$tag.prepend($("<img>").attr(argObj.mediaLibVars));
				}
			r = $tag;
			}
		
//		console.log(" -> _name: "+argObj._name+" r: "+r);
		return r;
		}



/* //////////////////////////////     FORMATS	 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */

//passing the command into this will verify that the format exists (whether it be core or not)

	this.format_currency = function(arg,globals)	{
		var r = "$"+globals.binds[globals.focusBind]+" ("+arg.value.value+")";
		globals.binds[globals.focusBind] = r
		return r;
		} //currency
	this.format_prepend = function(arg,globals)	{
		var r = arg.value.value+globals.binds[globals.focusBind];
		globals.binds[globals.focusBind] = r
		return r;
		} //prepend
	this.format_append = function(arg,globals)	{
		var r = globals.binds[globals.focusBind]+arg.value.value;
		globals.binds[globals.focusBind] = r
		return r;
		} //append
	this.format_truncate = function(arg,globals)	{
		var
			r = globals.binds[globals.focusBind].toString(); //what is returned. Either original value passed in or a truncated version of it.
			len = arg.value.value;
		if(!len || isNaN(len)){}
		else if(r.length <= len){}
		else	{
			if (r.length > len) {
				r = r.substring(0, len); //Truncate the content of the string
				r = $.trim(r.replace(/\w+$/, '')); //go back to the end of the previous word to ensure that we don't truncate in the middle of a word. trim trailing whitespace.
				r += '&#8230;'; //Add an ellipses to the end
				globals.binds[globals.focusBind] = r;
				}
			}
		return r;
		} //truncate



/* //////////////////////////////     HANDLERS		 \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\ */

	this.handler_format = function(cmd,globals)	{
		var format = cmd.args[0].key, r;
//		console.log(' -> cmd: '); console.dir(cmd);
		if(cmd.module == 'core' && this['format_'+format])	{
			for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
				try	{
					this['format_'+cmd.args[i].key](cmd.args[i],globals);
					}
				catch(e)	{}
				}
			}
		else if(cmd.module && cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based format. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core format specified");
			//invalid format specified.
			}
		return r;
		}

//passing the command into this will verify that the apply exists (whether it be core or not)
//may be able to merge this with the handler_format. We'll see after the two are done and if the params passed into the functions are the same or no.
// NOTE -> stopped on 'apply' for now. B is going to change the way the grammer hands back the response. Once he does that, I'll need to flatten the array into a hash to easily test if 'empty' or some other verb is set.
	this.handler_apply = function(cmd,globals)	{
//		console.log(" -> BEGIN handler_apply"); console.dir(cmd);
		var r = true;
		if(cmd.module == 'core')	{
			var argObj = this.args2obj(cmd.args); //an object is used to easily check if specific apply commands are present
			var $tag = globals.tags[globals.focusTag]; //shortcut. will work for all non 'img' based applies. img implicitly declares a tag.
			if(argObj.empty)	{$tag.empty()}
			if(argObj.hide)	{$tag.hide()}
			if(argObj.show)	{$tag.show()}
			if(argObj.remove)	{$tag.remove()}
			if(argObj.add)	{} //###TODO -> what to do here?
			
			
			
			if(argObj.attrib)	{
				globals.tags[globals.focusTag].attr(argObj.attrib.value,globals.binds[globals.focusBind]);
				}

//images get their own special handling.
			if(argObj.img)	{
				argObj._name = 'img'; //let the img handler know if it's img or imageurl. underscore is present in case a 'name' attribute is ever added to image.
				globals.tags[globals.focusTag] = this.apply_img($tag,argObj,globals.binds);
				}
			else if(argObj['input-value'])	{
				// ### TODO -> set tag value='' (for input tags)
				}
			else	{
				if(argObj.imageurl)	{
					argObj._name = 'imageurl'; //let the img handler know if it's img or imageurl. underscore is present in case a 'name' attribute is ever added to image.
					globals.binds[argObj.var] = this.apply_img($tag,argObj,globals.binds); //function returns an image url
					}
				if(argObj.append)	{
					$tag.append(globals.binds[globals.focusBind]);
					}
				if(argObj.prepend)	{
					$tag.prepend(globals.binds[globals.focusBind]);
					}
				}
			}
		else if(cmd.module && cmd.module.indexOf('#') >= 0)	{
			console.log(" -> non 'core' based apply. not handled yet");
			//use format in extension.
			}
		else	{
			console.log(" -> invalid core apply specified");
			r = false;
			//invalid format specified.
			}
		return r;
		}

	this.handler_BIND = function(cmd,globals)	{
		console.log("Now we bind"); console.dir(cmd);
		//scalar type means get the value out of the data object.
		globals.binds[cmd.Set.value] = (cmd.Src.type == 'scalar') ? jsonPath(this.data, cmd.Src.value) : cmd.Src.value;
		globals.focusBind = cmd.Set.value; // console.log(" -> globals.focusBind: "+globals.focusBind);
		return cmd.Set.value;
		}
	
	this.handler_render = function(cmd,globals){
		var r, argObj = this.args2obj(cmd.args); //an object is used to easily check if specific apply commands are present
//		console.log(" -> cmd: "); console.dir(cmd);
		if(argObj.wiki)	{
			var $tmp = $("<div>").append(value);
			//r = wikify($tmp.text()); //###TODO -> 
			globals.binds[cmd.Set.value] = $tmp.text();
			}
		else if(argObj.html)	{
			r = value; //if the content is already html, shouldn't have to do anything to it.
			}
		else if(argObj.dwiw)	{
			// ###TODO -> need to determine if content is wiki or html.
			r = value;
			}
		else	{
			//unrecognized command.
			r = value;
			}
		return r;
		}
		
	this.handler_stringify = function(cmd,globals)	{
		globals.binds[globals.focusBind] = JSON.stringify(globals.binds[globals.focusBind])
		return globals.binds[globals.focusBind];
		}

	this.handler_transmogrify = function(cmd,globals)	{
		console.warn(" -> NOT DONE YET ");
		//this will backically instantate a new peggy (or whatever it's called)
		}

	this.handler_is = function(cmd,globals)	{
		var value = globals.binds[globals.focusBind], r = false;
		for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
			switch(cmd.args[i].key)	{
				case "eq":
					if(value == cmd.args[i].value.value){ r = true;} break;
				case "ne":
					if(value != cmd.args[i].value.value){ r = true;} break;
				case "gt":
					if(Number(value) > Number(cmd.args[i].value.value)){r = true;} break;
				case "lt":
					if(Number(value) < Number(cmd.args[i].value.value)){r = true;} break;
				case "true":
					if(value){r = true;}; break;
				case "false":
					if(!value){r = true;}; break;
				case "blank":
					if(value == ''){r = true;}; break;
				case "notblank":
					if(!value || value == 0){r = true;}; break; //==, not ===, because zero could be passed in as a string.
				case "null":
					if(value == null){r = true;}; break;
				case "notnull":
					if(value != null){r = true;}; break;
				case "regex":
					var regex = new RegExp(cmd.args[i].value.value);
					if(regex.exec(value))	{r = true;}
					break;
				case "notregex":
					var regex = new RegExp(cmd.args[i].value.value);
					if(!regex.exec(value))	{r = true;}
					break;
				case "and":
					if(value != null){r = true;}; break; // ### TODO -> not done
				case "or":
					if(value != null){r = true;}; break; // ### TODO -> not done.
				}
			}
		globals.binds[globals.focusBind] = value;
		return value;
		}

	this.handler_math = function(cmd,globals)	{
		var value = Number(globals.binds[globals.focusBind]);
		if(!isNaN(value))	{
			for(var i = 0, L = cmd.args.length; i < L; i += 1)	{
				switch(cmd.args[i].key)	{
					case "add":
						value += cmd.args[i].value.value; break;
					case "sub":
						value -= cmd.args[i].value.value; break;
					case "mult":
						value *= cmd.args[i].value.value; break;
					case "div":
						value /= cmd.args[i].value.value; break;
					case "precision":
						value = value.toFixed(cmd.args[i].value.value); break;
					case "percent":
						value = (value/100).toFixed(0); break;
					}
				}
			globals.binds[globals.focusBind] = value;
			}
		else	{
			console.log(" -> handler_math was run on a value ["+globals.binds[globals.focusBind]+" which is not a number.");
			}
		return value;
		}

	this.handler_datetime = function(cmd,globals)	{

		var value = globals.binds[globals.focusBind];
		var argObj = this.args2obj(cmd.args), d = new Date(value*1000);


		if(isNaN(d.getMonth()+1))	{
			console.warn("In handler_datetime, value ["+value+"] is not a valid time format for Date()");
			}
//### FUTURE
//		else if(argObj.out-strftime)	{}
		else if (argObj.out.value == 'pretty')	{
			var shortMon = new Array('Jan','Feb','Mar','Apr','May','June','July','Aug','Sep','Oct','Nov','Dec');
			value = (shortMon[d.getMonth()])+" "+d.getDate()+" "+d.getFullYear()+ " "+d.getHours()+":"+((d.getMinutes()<10?'0':'') + d.getMinutes());
			}
		else if(argObj.out.value == 'mdy')	{
			value = (d.getMonth()+1)+"/"+d.getDate()+"/"+d.getFullYear();
			}
		else	{
			//invalid or no 'out' specified.
			}
		globals.binds[globals.focusBind] = value;
		return value;
		}

	this.executeCommands = function($tag,commands)	{
//		console.log(" -> running peggyInstance.executeCommands");
		var globals = {
			binds : {}, //an object of all the binds set in args.
			tags : {
				'$tag' : $tag
				}, //an object of tags.
			focusBind : '', //the pointer to binds of the var currently in focus.
			focusTag : '$tag' //the pointer to the tag that is currently in focus.
			}

		for(var i = 0, L = commands.length; i < L; i += 1)	{
			console.log(i+") commands[i]: handler_"+commands[i].type); console.dir(commands[i]);
			if(commands[i].type == 'command')	{
				try{
					this['handler_'+commands[i].name](commands[i],globals);
					}
				catch(e){
					console.error("Attempted to execute a handler for "+commands[i].name+", which either does not exist or resulted in an error.",e);
					}
				}
			else if(commands[i].type == 'IF')	{
				
				}
			else if(commands[i].type == 'BIND')	{
				
				this['handler_BIND'](commands[i],globals);
				}
			else	{
				//unrecognized type.
				}

			}
		}
	}


function makeTemplates()	{
	window.templates['someTemplate'] = $("#someTemplate").clone();
	window.templates['someOtherTemplate'] = $('#someOtherTemplate').clone();
	$("#someTemplate").empty().remove();
	$("#someOtherTemplate").empty().remove();
	}


function getRulesFromTextarea()	{
//	console.log(" -> getting rules from textarea");
	var success = false;
	try{
		var pegParserSource = PEG.buildParser($('#grammar').val());
		pegParser = eval(pegParserSource); //make sure pegParser is valid.
		success = true;
		}
	catch(e)	{
		console.warn("Could not build pegParser.");
		console.error(buildErrorMessage(e));
		}
	
	if(success)	{
		console.log(" -> successfully built pegParser");
//		translateTemplate();
		}
	}

/*
function getRules(rulesURL)	{
	console.log(' -> fetching rules: '+rulesURL);
	var rulesReq = $.ajax({
		url : rulesURL,
		dataType : 'text',
		error : function(a,b,c)	{
			console.warn("Got to the AJAX 'error'");
			console.log(a,b,c);
			},
		complete : function(a,b,c)	{
			console.log("Got to the AJAX 'complete'");
//			console.log(a,b,c);
			},
		success : function(data)	{
			console.log("Successfully fetched "+rulesURL);
			$('#grammar').val(data);
//			console.debug(data);
			var success = false;
			try{
				var pegParserSource = PEG.buildParser($('#grammar').val());
				pegParser = eval(pegParserSource);
				success = true;
				}
			catch(e)	{
				console.warn("Could not build pegParser.");
				console.log(buildErrorMessage(e));
				}
			
			if(success)	{
				console.log(" -> successfully built pegParser");
				translateTemplate();
				}
			}
		});
	}
*/



$(function() {
	console.log("Document is ready. Let's do stuff.");
	makeTemplates();
	getRulesFromTextarea(); //'new_db_rules.pegjs'

	bob = new peggy('someTemplate',sampleProdData);
	frank = new peggy('someOtherTemplate',sampleProdData);
	$("#contentGoesHere").append(bob.translateTemplate());
	});
</script>
</head>
<body>

<div id='contentGoesHere' style='border:1px dashed #c00; padding:10px;'></div>
<br />
<!--
	<div data-bind="text(shipaddress2);"  title='address 2'></div>

	<span data-bind="text(shipcity);"  title='city'></span>
	<span data-bind="text(shipregion);"  title='state'></span>
	<span data-bind="text(shippostal);"  title='zip'></span>
	<div data-bind="text(shipcountrycode);" title='country'></div>
-->

<textarea id='grammar' rows='20' cols='50' style='display:none;'>
dataTLC
 = grammar+
 
grammar
 = IfStatement _ lb*
 / BindStatement _ lb*
 / command:(command) _ lb* { return command }

// command name and module name must start with a letter or underscore
command
 = _ module:([A-Za-z0-9_]+ "#")? cmd:[A-Za-z0-9_]+ args:((ws+ value)+)? _ lb* {
     return {
       type: "command",
       module: module ? module[0].join("") : "core",
       name: cmd.join("").toLowerCase(),
       args: args ? args.map(function(a) { return a[1] }) : null
     }
   }


// ** BIND **
// bind $var 'something';    (jsonpath lookup)
// bind $var $someothervar;  (jsonpath lookup)
// bind $var ~tag;           (returns tag id/path)
// bind ~tag '#tagid';       jQuery('#tagid')
// bind ~tag $tagid          jQuery($tagid)
BindStatement
 = "bind" _ set:(variable / tag) _ src:(variable / scalar / tag) _ lb+ {
  return { type:"BIND", Set:set, Src:src } 
  }



IfStatement
  = "if" _ "(" _ condition:command _ ")" _ ifStatement:Block elseStatement:(_ "else" _ Block)? _ lb+ {
      return {
        type:     "IF",
        When:     condition,
        IsTrue:   ifStatement,
        IsFalse: elseStatement !== null ? elseStatement[3] : null
      };
   }


Block
  = "{{" _ statements:(StatementList _)? "}}" {
      return {
        type:       "Block",
        statements: statements !== null ? statements[0] : []
      };
    }

StatementList
  = head:Statement tail:(_ Statement)* {
      var result = [head];
      for (var i = 0; i < tail.length; i++) {
        result.push(tail[i][1]);
      }
      return result;
    }

Statement
  = Block
  / command+
  



/* value types */

// ~tag is a reference to a jquery object
tag 
 = "~" tag:([a-zA-Z0-9\-_]+) {
   // tag table should maintain reference to tags on DOM
   return { type:"tag", value:tag.join(""), jq:null }
   }

boolean 
 = "true" {return{ "type":"boolean", "value": true }}
 / "false" {return{ "type":"boolean", "value": false }}

// longopt start with a --
longopt
 = "--" k:([a-zA-Z]+) "=" v:( value )  {
    return {
       type: "longopt",
       key: k.join(""),
       value: v
       }
    }
 / "--" k:([a-zA-Z]+) {
    return {
      type: "longopt",
      key: k.join(""),
      value: null
      }
    }


// scalar (string)
// NOTE: at this point there is no way to escape a ' in a string.
// 
scalar
 = "'" v:([^']*) "'" {
     return { 
       type: "scalar",
       value: v.join("")
     } 
   }

// Variables can't start with a number
variable
 = "$" v:([a-zA-Z0-9_]*) { 
     return { 
       type: "variable",
       value: v.join("")
     } 
   }

integer
  = digits:[0-9]+ { 
      return { 
        type: "integer", 
        value: parseInt(digits.join(""), 10) 
      }
    }

hexcolor 
  = "#" v:([A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9][A-Fa-f0-9]) {
     return { type:"hexcolor", value: v.join("")  }
     }

additive
  = left:muldiv _ sign:[+-] _ right:additive { 
      return { 
        type: "command", 
        name:sign, 
        args:[left,right] 
      }
    }
  / muldiv

muldiv
  = left:primary _ sign:[*/] _ right:muldiv {
      return { 
        type: "command", 
        name: sign, 
        args:[left, right] 
      }
    }
  / primary

primary
  = (variable / integer)
  / "(" _ additive:additive _ ")" { return additive; }

value
 = longopt / variable / integer / scalar / boolean / tag / hexcolor / additive 

// /* i am a comment (i can only appear before a command) */
comment
  = "/*" (!"*/" SourceCharacter)* "*/" { return{}; }

SourceCharacter
  = .

ws
 = [ \t\n]

_
 = (ws / comment)*

lb
 = ";"




</textarea>





<div id='someTemplate'>
	<img data-tlc="bind $var '$.product.prod_image1'; apply --img --media=$var --width=100 --height=100 --bgcolor='#000000' --append;" />
	<h1 data-tlc="bind $var '$.product.name'; format --append=' - thats right! '; apply --append;"></h1>
	<h2 data-tlc="bind $var '$.product.base_price'; format --currency='USD';  format --prepend='price tag: '; apply --append;"></h2>
	<h5 data-tlc="bind $var '$.product.base_price'; math --add=20 --sub=10 --precision=0 --mult=3; format --currency='USD';  format --prepend='Fake msrp: '; apply --append;"></h5>
	<h3 data-tlc="bind $var '$.product.created'; datetime --out='pretty'; apply --append;"></h3><br />
	<div data-tlc="bind $var '$.product.prod_desc'; format --truncate=250; apply --append;"></div><br />
	<div data-tlc="bind $var '$.product.prod_hash'; stringify $var; apply --append;">Stringify: </div>
	<div data-tlc="bind $var '$.product.base_price'; apply --attrib='data-garbage';">should have data-garbage set</div>
</div>

<div id='someOtherTemplate' data-tlc="bind $var '$.product.prod_name'; tag --overwrite;">
	
	<h3 data-tlc="bind $var '$.product.prod_msrp'; tag --overwrite;">Lorem Ispsum Producismo Namola</h3>
	<img data-tlc="bind $var '$.product.prod_image1'; apply --img --media=$var --width=100 --height=100 --bgcolor='#000'  --append;" />
	<div data-tlc="bind $var '$.product.prod_desc'; tag --overwrite;"></div>
</div>





</body>
</html>
