<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>



<script type='text/javascript'>


window.showContent = function(){}; //placeholder.


var router = {
	routes : {}, //an object, not an array. order is not required because route matches are implicit unless they define themselves otherwise.
	handlers : {}, //functions executed by route.
	
	//proper way to add a route to the routes table. will have validation.
	addRoute : function(route,name)	{
		if(route && name)	{
			if(this.routes[route])	{
				console.warn("route: "+route+" was just overwritten");
				}
			this.routes[route] = {'name' : name, 'isRegExp' : route instanceof RegExp};
			}
		else	{
			// either route or name not specified. throw error.
			}
		},
	//proper way to add a handler. will have validation.
	addHandler : function(name,callback)	{
		if(name && callback)	{
			this.handlers[name] == callback;
			}
		else	{
			// eithr name or callback not specified.  ### TODO -> add error.
			}
		},
	thisIsAValidRegExp : function(pattern)	{
		var parts = pattern.split('/'),
				regex = pattern,
				options = "";
			if (parts.length > 1) {
				regex = parts[1];
				options = parts[2];
			}
			try {
				new RegExp(regex, options);
				return true;
			}
			catch(e) {
				return false;
			}
		},
	route2Regex : function(route)	{
		var rArr = route.split('/');
		for(var i = 0, L = rArr.length; i < L; i += 1)	{
			if(rArr[i].indexOf(':') >= 0)	{
				rArr[i] = rArr[i].split(':')[0] || "";
				rArr[i] +=  '([^\\/]+)';
				}
			else	{
				//no variables.
				}
			}
		return rArr.join('\/');
		},
	getKeys : function(obj)	{
		return Object.keys(obj); // ### TODO -> Object.keys isn't backward compatible. update prototype or use jquery $map.
//		return $.map: $.map(h, function(v,k) { return k; });
		},
	testRoute : function(thisRoute,hash)	{
//		console.log("BEGIN testRoute","thisRoute: "+thisRoute);
		var r = null; //what is returned.
		//it's the simple things.... check for an exact match.
		if(thisRoute == hash)	{
			r = thisRoute;
			}
		else	{
			//not an exact match. Check to see if the route is a regex already.
			var pattern = false;
			if(router.routes[thisRoute].isRegExp)	{
				pattern = thisRoute;
				}
			//now check to see if the route includes any variables and, if so, convert them to a regex
			else if(thisRoute.indexOf(':') >= 0)	{
				pattern = router.route2Regex(thisRoute);
//				console.log(' -----> pattern: '+pattern);
				}
			else	{
				//not a regex.  contains no vars. Exact match has already been eliminated. 
				r = false;
				}

			if(pattern)	{
				var regex = new RegExp(pattern), isMatch = regex.exec(hash);
				//regex.exec[0] will be the match value. so comparing that to the hash will ensure no substring matches get thru.
				//substring matches can be accomplished w/ a regex in the route.
				if(isMatch && isMatch[0] == hash)	{
					r = thisRoute;
					}
//				console.log("pattern: "+pattern, "    route: "+thisRoute, "    regex.test: "+regex.exec(hash));
				}
			else	{
//				console.log("no regex for route: "+thisRoute);
				r = false;
				}
			}
		return r;
		},
	getRoute : function(hash)	{
		var route = null;
		for(var index in router.routes)	{
			if(route = router.testRoute(index,hash))	{break;}
			}
		return route;
		},
	executeHandler : function(route,hash)	{
		if(route && hash)	{
			if(router.routes[route])	{
				
				}
			else	{
				//hhhmm... got all this way and the route isn't valid? seems unlikely but must be handled.
				}
			}
		else	{
			// either route or hash not passed.
			}
		var hArr = hash.split('/'), vars = {};
		},
	handleHashChange : function()	{
		//probably should check to make sure first three characters are #!/
		var hash = location.hash.substr(3).replace(/\/$/, ""), route;
//		console.log(" -> hash: "+hash);
//if we return to routes being an array, this is how the loop goes.
//		for(var i = 0,L = router.routes.length; i < L; i += 1)	{
//			console.log(" -> route: ",router.getKeys(router.routes[i])[0]); 
//			if(route = router.testRoute(router.getKeys(router.routes[i])[0],hash))	{console.log("WOOOOOOOOOOOOOOOOOT"); break;}
//			}
		route = router.getRoute(hash);
		if(route)	{
			console.log(" -> WOOT! valid route: "+route);
			}
		else	{
			console.log(" -> Uh Oh! no valid route found for "+hash);
			//what to do here?
			}
/*		for(var i = 0; i < rArr.length; i += 1)	{
			var r = rArr[i];
			if(r.charAt(0) == ':')	{
				vars[r.substring(1)] = hArr[i];
				}
			}
//		console.log("Vars: ",vars);
*/		}
	};


router.addRoute(/^(.*?)\/open$/,"product");
router.addRoute("product/:pid/:seo","product");
router.addRoute("product/:pid","product");
router.addRoute("category/:path","category");
router.addRoute("category/:path/:seo","category");
router.addRoute("company","company");
router.addRoute("company/:show","company");


router.addRoute("*","homepage"); //hhhhmmm... this a good or a bad idea. seems bad. maybe a / or * as the route. or a bang... for no hashBang present

router.addHandler("product",function(vars){  //third param of extensions/dependencies array? Would allow us to not load extensions till they're needed. speeds up init.
	console.log(' -> pid: '+pid);
	});
router.addHandler("category",showContent);
router.addHandler("company","app.myRIA.a.showCompany");


window.addEventListener("hashchange", router.handleHashChange, false);

//console.dir(router.routes);
</script>



</head>

<body>

<a href='#!/product/XYZ/'>product link - XYZ</a><br />
<a href='#!/product/ABC/seo.html'>product link - ABC</a><br />
<a href='#!/company/'>#!/company/</a><br />
<a href='#!/company/about'>#!/company/about</a>
<br />
<a href='#!/tacos'>#!/tacos</a>

</body>
</html>
