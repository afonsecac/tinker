<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Untitled Document</title>


<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.10.2/jquery.min.js"></script>
<script type='text/javascript'>


var app = {
	u : {
		//turn a set of key value pairs (a=b&c=d) into an object. pass location.search.substring(1); for URI params or location.hash.substring(1) for hash based params
		kvp2Array : function(s)	{
			var r = false;
			if(s && s.indexOf('=') > -1)	{
				r = s?JSON.parse('{"' + s.replace(/&/g, '","').replace(/=/g,'":"') + '"}',function(key, value) { return key===""?value:decodeURIComponent(value) }):{};
				}
			else	{}
			return r;
			} //kvp2Array
		}
	}



var router = {
	initRoutes : [], //get run once, at router init. allows for handling of URI vars et all.
	hashRoutes : [], //an object, not an array. order is not required because route matches are implicit unless they define themselves otherwise.
	aliases : {}, //functions executed by route.
	
//proper way to add a route to the routes table. will have validation.
	appendHash : function(arr)	{
		return this._addInitOrHash('hash','append',arr);
		},
	prependHash : function(arr)	{
		return this._addInitOrHash('hash','prepend',arr);
		},

	_addInitOrHash : function(mode,method,arr)	{
		var r = false; //what is returned.
		if((method == 'append' || method == 'prepend') && (mode == 'init' || mode == 'hash'))	{
			if(arr[0] && arr[2])	{ //route isn't validated against because a blank route is a valid route (homepage)
				if(router.matchFunctions[arr[0]])	{
					var obj = {'type' : arr[0], 'route' : arr[1], 'callback' : arr[2], 'p' : arr[3]};
					method == 'prepend' ? this[mode+'Routes'].unshift(obj) : this[mode+'Routes'].push(obj);
					r = true;
					}
				else	{
					console.warn("In _addInitOrHash, for route "+arr[1]+" type was set as "+arr[0]+" which is not valid");
					}				
				}
			else	{
				console.warn("In _addInitOrHash, type ["+arr[0]+"] or route ["+arr[1]+"] or callback [typeof: "+(typeof arr[2])+"] was not defined and all are required.");
				}
			}
		else	{
			console.warn("In _addInitOrHash, method ["+method+"] and or mode ["+mode+"] either not specified or not valid.");
			}
		return r;
		},
		
	appendInit : function(arr)	{return this._addInitOrHash('init','append',arr);},
	prependInit : function(arr)	{return this._addInitOrHash('init','prepend',arr);},
		
	//proper way to add an alias. will have validation.
	addAlias : function(name,callback)	{
		if(name && callback)	{
			router.aliases[name] = callback;
			}
		else	{
			// eithr name or callback not specified.  ### TODO -> add error.
			}
		},
		
	_buildMatchParams : function(route,hash,keysArr)	{
		var regex = new RegExp(/{{(.*?)}}/g); //### TODO -> this regex needs love. only doing first match.
		var matchVarsArr = regex.exec(route), vars = {};
		
		console.log(" -> matchVarsArr: "); console.dir(matchVarsArr);
		
		if(matchVarsArr && matchVarsArr.length)	{
			for(var i = 0, L = matchVarsArr.length; i < L; i += 1)	{
				vars[matchVarsArr[i]] = keysArr[i];
				}
			}
		return vars;
		},
//The route type functions all get passed the same vars, routeObj and hash.
//the function should return false is the hash does not match the route.
//the function should return an object if a match is 
	matchFunctions : {
		'exact' : function(routeObj,hash){
			var r = false;
			if(routeObj.route == hash)	{
				r = {'exact':hash};
				}
			return r;
			},
		'match' : function(routeObj,hash){
			var pattern = routeObj.route.replace(/{{(.*?)}}/g,'([^\\/]+)'), r = false, regex = new RegExp(pattern), isMatch = regex.exec(hash);
//regex.exec[0] will be the match value. so comparing that to the hash will ensure no substring matches get thru.
//substring matches can be accomplished w/ a regex in the route.
			if(isMatch && isMatch[0] == hash)	{
				r = {'match' : isMatch, 'params' : router._buildMatchParams(routeObj.route,hash,isMatch)};
				}
			return r;
			},
		'function' : function(routeObj,hash){
			// ### TODO -> need to write this.
			return routeObj.route(routeObj,hash);
			},
		'regexp' : function(routeObj,hash){
			var regex = new RegExp(routeObj.route), r = false, isMatch = regex.exec(hash);
			if(isMatch)	{
				// ### TODO -> needs to run the _buildMatchParams util.
				r = {'regexp' : isMatch};
				}
			return r;
			}
		},
//compares an individual route in the routes array against the hash to check for a match.
//The matchFunction response and the routeObj are copied and returned.
	_doesThisRouteMatchHash : function(routeObj,hash)	{
		var r = null;
		if(routeObj.type && typeof router.matchFunctions[routeObj.type] == 'function')	{
			r = router.matchFunctions[routeObj.type](routeObj,hash);
			if(r)	{
				r = $.extend({},routeObj,r); //r last trumps whatever was in the routeObj. allows r to 'change' things.
				}
			}
		else	{
			console.warn("for route "+routeObj.route+", routeObj.type is not set ["+routeObj.type+"] OR typeof is not a function ["+(typeof router.matchFunctions[routeObj.type])+"].");
			console.dir(routeObj);
			}
		return r;
		},
//Goes through the entire list of routes, in order.
//executes the match method (exact, function, regexp, etc) to see if hash is a match.
//once a match is found, processing is stopped, which means only 1 match per hash. 
//	-> may at some point enable stacking, but it'll be off by default.
	_getRouteObj : function(hash)	{
		var route = null;
		for(var i = 0,L = router.hashRoutes.length; i < L; i += 1)	{
			var isMatchArr = router._doesThisRouteMatchHash(router.hashRoutes[i],hash); //will return an array where 0 is the 'match' from the regex and subsequent entries are the matched values. (ex: for product/PID , spot 1 is PID)
			if(isMatchArr)	{
				route = isMatchArr;
				break;
				}
			}
		return route;
		},
	_executeCallback : function(routeObj)	{
		//if the callback is a string, then it should correspond to a handler.
		if(typeof routeObj.callback === 'string')	{
			console.log(" -> callback is a string: "+routeObj.callback)
			if(router.aliases[routeObj.callback])	{
				router.aliases[routeObj.callback](routeObj);
				}
			else	{
				//no matching handler found.
				console.warn("In _executeCallback, handler ["+routeObj.callback+"] specified does not exist.");
				}
			}
		else if(typeof routeObj.callback === 'function')	{
			routeObj.callback(routeObj);
			}
		else	{
			console.error("In _execute handler, invalid type for routeObj.callback. typeof: "+(typeof routeObj.callback));
			//unrecognized type for calback.
			}
		},

	init : function()	{
		console.log("INIT executed");
		
		vars = {
			location : document.location,
			hash : location.hash,
			uriParams : {},
			hashParams : {}
			}
		
//this would get added at end of INIT. that way, init can modify the hash as needed w/out impacting.
		window.addEventListener("hashchange", router.handleHashChange, false);
		},

	handleHashChange : function()	{
		if(location.hash.indexOf('#!') == 0)	{
			var routeObj = router._getRouteObj(location.hash.substr(2).replace(/\/$/, ""));
			if(routeObj)	{
				routeObj.hash = location.hash;
				console.log(" -> WOOT! valid route!"); // console.dir(routeObj);
				router._executeCallback(routeObj);
				}
			else	{
				console.log(" -> Uh Oh! no valid route found for "+location.hash);
				//what to do here?
				}
			}
		else	{
			console.log(" -> not a hashbang");
			//is not a hashbang. do nothing.
			}
		}
	};


//hashes are checked with each hash change.  They can be added at any time, before or after the router.init function is run.
router.appendHash(['regexp',/^(.*?)\/open$/,"product",['a','b','c']]); //a/b/c get mapped to the return values of the regular expression and are passed into 'product' as an object.
router.appendHash(['exact',"company","company"]);
router.appendHash(['match',"product/{{pid}}/{{seo}}",function(v){console.log("EXECUTED a function passed as callback."); console.dir(v)}]);
router.appendHash(['match',"product/{{pid}}","product"]);
router.appendHash(['match',"category/{{path}}","category"]);
router.appendHash(['match',"category/{{path}}/{{seo}}","category"]);
router.appendHash(['function',function(v){},"product"]); //function would return false if not true. anything passed gets returned and it gets treated as true and passed into product
router.appendHash(['match',"company/{{show}}","company"]);

// #### TODO -> these two need work.
router.appendHash(['exact',"404","company"]);
router.appendHash(["exact","",function(){console.log("go to homepage");}]); //hhhhmmm... this a good or a bad idea. seems bad. maybe a / or * as the route. or a bang... for no hashBang present

router.appendInit(['function',function(v){},function(v){}]);



router.addAlias("default",function(vars){  //third param of extensions/dependencies array? Would allow us to not load extensions till they're needed. speeds up init.
	console.log(' -> default alias');
	});


router.addAlias("product",function(vars){  //third param of extensions/dependencies array? Would allow us to not load extensions till they're needed. speeds up init.
	console.log(' -> product alias');
	});

router.addAlias("category",function(){
	console.log('category alias executed');
	});
router.addAlias("company",function(){
	console.log('company alias executed');
	});


//console.dir(router.routes);




</script>



</head>

<body onload="router.init();">

<a href='#!product/XYZ/'>product link - XYZ</a><br />
<a href='#!product/ABC/seo.html'>product link - ABC</a><br />
<a href='#!company'>#!company</a><br />
<a href='#!/company'>#!/company</a><br />
<a href='#!'>#!</a><br />
<a href='#!company/about'>#!/company/about</a><br />
<a href='#tacos'>#/tacos</a><br />
<a href='#!burritos'>#!/burritos</a><br />

<pre>

the init functions needs to get URI vars and hash vars passed in.

support for an 'addRouteType'? 
 -> if so, each route 'match' validation would need to be appropriately named in an object instead of crammed into doesThisRouteMatchHash
 -> 'match' could turn the route into a regex, then run the regexp 'match' function.
</pre>

</body>
</html>
